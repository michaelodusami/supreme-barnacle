A solid assessment on **Trees** must cover fundamental traversal, property checks, and manipulation of both Binary Trees and Binary Search Trees (BSTs).

Here is the complete set of 10 problems focusing on Tree Data Structures, following all your constraints.

| ID | Difficulty | Title | Problem Description | Example Case |
| :---: | :---: | :--- | :--- | :--- |
| 1 | Easy | **Inorder Tree Traversal** | Given the `root` of a binary tree, return the list of values resulting from its **inorder traversal** (Left, Root, Right). The function signature should be `def inorder_traversal(root: Optional[TreeNode]) -> list[int]:`. (Assume the definition of `TreeNode` is available). | **Input:** `root` of tree: $[1, \text{null}, 2, 3]$ (Root is 1, right child is 2, left child of 2 is 3)<br>**Expected Output:** `[1, 3, 2]` |
| 2 | Easy | **Maximum Depth of Binary Tree** | Given the `root` of a binary tree, return its maximum depth (the number of nodes along the longest path from the root node down to the farthest leaf node). The function signature should be `def max_depth(root: Optional[TreeNode]) -> int:`. | **Input:** `root` of tree: $[3, 9, 20, \text{null}, \text{null}, 15, 7]$<br>**Expected Output:** `3` |
| 3 | Easy | **Validate Binary Search Tree (Basic)** | Given the `root` of a binary tree, determine if it is a valid **Binary Search Tree (BST)**, where for every node: its left subtree contains only nodes with values less than the node's value, and its right subtree contains only nodes with values greater than the node's value. The function signature should be `def is_valid_bst(root: Optional[TreeNode]) -> bool:`. | **Input:** `root` of tree: $[2, 1, 3]$<br>**Expected Output:** `True` |
| 4 | Medium | **Level Order Traversal** | Given the `root` of a binary tree, return its **level order traversal** (i.e., breadth-first traversal). The output should be a list of lists, where each inner list represents the nodes at that level. The function signature should be `def level_order(root: Optional[TreeNode]) -> list[list[int]]:`. | **Input:** `root` of tree: $[3, 9, 20, \text{null}, \text{null}, 15, 7]$<br>**Expected Output:** `[[3], [9, 20], [15, 7]]` |
| 5 | Medium | **Invert Binary Tree** | Given the `root` of a binary tree, invert the tree, and return its root. Inverting a tree means swapping the left and right children of every single node. The function signature should be `def invert_tree(root: Optional[TreeNode]) -> Optional[TreeNode]:`. | **Input:** `root` of tree: $[4, 2, 7, 1, 3, 6, 9]$<br>**Expected Output:** `root` of tree becomes $[4, 7, 2, 9, 6, 3, 1]$ |
| 6 | Medium | **Lowest Common Ancestor (LCA) of a BST** | Given a **Binary Search Tree (BST)**, find the lowest common ancestor (LCA) of two given nodes, $p$ and $q$. The LCA is defined as the lowest node in the tree that has both $p$ and $q$ as descendants (where a node can be a descendant of itself). The function signature should be `def lowest_common_ancestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:`. | **Input:** `root` of BST: $[6, 2, 8, 0, 4, 7, 9, \text{null}, \text{null}, 3, 5]$, $p=2$, $q=8$<br>**Expected Output:** `6` |
| 7 | Medium | **Path Sum II** | Given the `root` of a binary tree and an integer `targetSum`, return all root-to-leaf paths where the sum of the node values in the path equals `targetSum`. The function signature should be `def path_sum(root: Optional[TreeNode], targetSum: int) -> list[list[int]]:`. | **Input:** `root` of tree: $[5, 4, 8, 11, \text{null}, 13, 4, 7, 2, \text{null}, \text{null}, 5, 1]$, ` targetSum = 22$<br>**Expected Output:**  `[[5, 4, 11, 2], [5, 8, 4, 5]]`| | 8 | Medium | **Flatten Binary Tree to Linked List** | Given the`root`of a binary tree, flatten it into a "linked list" **in-place**. The "linked list" should be in the same order as a pre-order traversal (Root, Left, Right). After flattening, the left pointer of each node should always be`null`and the right pointer should point to the next node. The function signature should be`def flatten(root: Optional[TreeNode]) -\> None:` . | **Input:**  `root`of tree: $[1, 2, 5, 3, 4, \text{null}, 6]$<br>**Expected Output:**`root`becomes $[1, \text{null}, 2, \text{null}, 3, \text{null}, 4, \text{null}, 5, \text{null}, 6]$ | | 9 | Medium | **Binary Tree Right Side View** | Given the`root`of a binary tree, imagine yourself standing on the right side of it. Return the values of the nodes you can see ordered from top to bottom. The function signature should be`def right\_side\_view(root: Optional[TreeNode]) -\> list[int]:` . | **Input:**  `root`of tree: $[1, 2, 3, \text{null}, 5, \text{null}, 4]$<br>**Expected Output:**`[1, 3, 4]`| | 10 | Hard | **Serialize and Deserialize Binary Tree** | Design an algorithm to serialize (convert a tree to a string) and deserialize (convert a string back to a tree) a binary tree. There should be a class with two methods:`serialize`and`deserialize` . The function signatures should be within a class  `Codec` :  `class Codec: def serialize(self, root: Optional[TreeNode]) -\> str:`and`def deserialize(self, data: str) -\> Optional[TreeNode]:` . | **Input (Tree):**  `root`of tree: $[1, 2, 3, \text{null}, \text{null}, 4, 5]$<br>**Expected Output (Serialization):** A string representation like`"1,2,null,null,3,4,null,null,5,null,null"\`<br>**Expected Output (Deserialization):** The original tree structure. |

-----

Please provide your Python code for each of the 10 problems now. Use the ID and Title as comments for each solution function.