The final crucial area for a Senior Technical Interview is **Graphs**. This assessment covers essential traversal algorithms, shortest path algorithms, topological sorting, and minimum spanning trees.

Here is the complete set of 10 problems focusing on Graph Data Structures and Algorithms, following all your constraints.

| ID | Difficulty | Title | Problem Description | Example Case |
| :---: | :---: | :--- | :--- | :--- |
| 1 | Easy | **Breadth-First Search (BFS) Traversal** | Given an undirected graph (represented by an adjacency list) and a starting node, return a list of nodes visited in **Breadth-First Search (BFS)** order. Assume node values are integers. The function signature should be `def bfs_traversal(graph: dict[int, list[int]], start_node: int) -> list[int]:`. | **Input:** `graph = {1: [2, 3], 2: [1, 4], 3: [1, 5], 4: [2], 5: [3]}`, `start_node = 1`<br>**Expected Output:** `[1, 2, 3, 4, 5]` |
| 2 | Easy | **Depth-First Search (DFS) Traversal** | Given an undirected graph (represented by an adjacency list) and a starting node, return a list of nodes visited in **Depth-First Search (DFS)** order. Assume node values are integers. The function signature should be `def dfs_traversal(graph: dict[int, list[int]], start_node: int) -> list[int]:`. | **Input:** `graph = {1: [2, 3], 2: [4], 3: [5], 4: [], 5: []}`, `start_node = 1`<br>**Expected Output:** `[1, 2, 4, 3, 5]` |
| 3 | Easy | **Find The Center of Star Graph** | There is an undirected **star graph**, consisting of $n$ nodes labeled from 1 to $n$. A star graph is a graph where there is one center node connected to every other single node. You are given an array of edges, where `edges[i] = [u_i, v_i]` indicates that there is an edge between $u_i$ and $v_i$. Return the value of the center node. The function signature should be `def find_center(edges: list[list[int]]) -> int:`. | **Input:** `edges = [[1, 2], [2, 3], [4, 2]]`<br>**Expected Output:** `2` |
| 4 | Medium | **Clone Graph** | Given a reference to a node in a connected undirected graph, return a deep copy (clone) of the graph. The function signature should be `def clone_graph(node: Optional[Node]) -> Optional[Node]:`. (Assume the definition of `Node` with `val` and `neighbors` is available). | **Input:** A node representing a graph where Node 1 connects to 2 and 4, and Node 3 connects to 2 and 4.<br>**Expected Output:** A reference to the cloned Node 1, representing an identical, distinct graph structure. |
| 5 | Medium | **Course Schedule I (Cycle Detection)** | There are a total of `numCourses` to take, labeled from 0 to `numCourses - 1`. You are given a list of `prerequisites` where `prerequisites[i] = [a_i, b_i]` indicates that you must take course $b_i$ before taking course $a_i$. Determine if it is possible to finish all courses. This is a cycle detection problem in a directed graph. The function signature should be `def can_finish(numCourses: int, prerequisites: list[list[int]]) -> bool:`. | **Input:** `numCourses = 2`, `prerequisites = [[1, 0]]`<br>**Expected Output:** `True` (Can take 0, then 1) |
| 6 | Medium | **Topological Sort (Kahn's Algorithm)** | Given a directed acyclic graph (DAG) represented by the number of nodes $n$ and a list of directed edges, return a valid **topological ordering** of the nodes. If there are multiple valid orders, return any one. Use **Kahn's Algorithm** (in-degree based). The function signature should be `def topological_sort(n: int, edges: list[list[int]]) -> list[int]:`. | **Input:** $n=4$, `edges = [[1, 0], [2, 0], [3, 1], [3, 2]]`<br>**Expected Output:** `[3, 1, 2, 0]` (Order may vary) |
| 7 | Medium | **Cheapest Flights Within K Stops** | There are $n$ cities connected by some flights. You are given an array of `flights` where $\text{flights}[i] = [from_i, to_i, price_i]$. Find the cheapest price to travel from a city `src` to a city `dst` with at most $k$ stops. If there is no such route, return -1. The function signature should be `def find_cheapest_price(n: int, flights: list[list[int]], src: int, dst: int, k: int) -> int:`. (Hint: A modification of BFS or Bellman-Ford). | **Input:** $n=3$, `flights = [[0, 1, 100], [1, 2, 100], [0, 2, 500]]`, `src=0`, `dst=2`, $k=1$<br>**Expected Output:** `200` (Route $0 \to 1 \to 2$) |
| 8 | Medium | **Dijkstra's Shortest Path** | Given a weighted, directed graph (represented by a list of edges) and a source node `src`, find the shortest distance from `src` to all other nodes. Return a dictionary mapping nodes to their minimum distance. The function signature should be `def dijkstra(n: int, edges: list[tuple[int, int, int]], src: int) -> dict[int, int]:`. | **Input:** $n=5$, `edges = [(0, 1, 10), (0, 2, 5), (1, 3, 1), (2, 1, 3), (2, 3, 9), (2, 4, 2), (3, 4, 4), (4, 3, 6), (4, 0, 7)]`, `src=0`<br>**Expected Output:** `{0: 0, 1: 8, 2: 5, 3: 9, 4: 7}` |
| 9 | Medium | **Word Ladder** | Given two words, `beginWord` and `endWord`, and a list of `wordList`, find the length of the shortest transformation sequence from `beginWord` to `endWord`, such that: 1. Only one letter can be changed at a time. 2. Each transformed word must exist in `wordList`. Return 0 if no such sequence exists. This is a classic **BFS** problem. The function signature should be `def ladder_length(beginWord: str, endWord: str, wordList: list[str]) -> int:`. | **Input:** `beginWord = "hit"`, `endWord = "cog"`, `wordList = ["hot", "dot", "dog", "lot", "log", "cog"]`<br>**Expected Output:** `5` (Sequence: $\text{hit} \to \text{hot} \to \text{dot} \to \text{dog} \to \text{cog}$) |
| 10 | Hard | **Minimum Spanning Tree (Prim's Algorithm)** | Given a list of all edges of an undirected, connected, weighted graph, find the total weight of a **Minimum Spanning Tree (MST)** using **Prim's Algorithm**. The edge list is $\text{edges}[i] = [u_i, v_i, weight_i]$. The function signature should be `def min_cost_mst_prim(n: int, edges: list[list[int]]) -> int:`. | **Input:** $n=4$, `edges = [[0, 1, 10], [0, 2, 6], [0, 3, 5], [1, 3, 15], [2, 3, 4]]`<br>**Expected Output:** `19` (Edges: $[0, 3, 5], [2, 3, 4], [0, 2, 6]$ is wrong. Edges: $[0, 3, 5], [2, 3, 4], [0, 1, 10]$. Total $5+4+10=19$). Correct set of edges: $[0, 3, 5], [2, 3, 4], [0, 2, 6]$ or $[0, 1, 10]$. The correct MST is: Edges with weight 4, 5, 10 or 4, 5, 6. The total cost is $5+4+6=15$ or $5+4+10=19$. Let's check. Total weight should be 15. The MST edges are $(2, 3, 4), (0, 3, 5), (0, 2, 6)$. Total cost: $4+5+6=15$. (Corrected Example) |

-----

Please provide your Python code for each of the 10 problems now. Use the ID and Title as comments for each solution function.