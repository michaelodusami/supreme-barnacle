A set of **Matrix** problems is crucial for any technical interview, as they often combine concepts like arrays, searching, and sometimes dynamic programming.

Here is a complete assessment focusing exclusively on common Matrix-based Data Structures and Algorithms problems, following all your constraints.

| ID | Difficulty | Title | Problem Description | Example Case |
| :---: | :---: | :--- | :--- | :--- |
| 1 | Easy | **Search a 2D Matrix** | Write an efficient algorithm that searches for a `target` value in an $m \times n$ matrix. This matrix has the following properties: integers in each row are sorted from left to right, and the first integer of each row is greater than the last integer of the previous row. The function signature should be `def search_matrix(matrix: list[list[int]], target: int) -> bool:`. | **Input:** `matrix = [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]]`, `target = 3`<br>**Expected Output:** `True` |
| 2 | Easy | **Diagonal Traverse** | Given an $m \times n$ matrix, return all elements of the matrix in a diagonal order. The function signature should be `def find_diagonal_order(matrix: list[list[int]]) -> list[int]:`. | **Input:** `matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]`<br>**Expected Output:** `[1, 2, 4, 7, 5, 3, 6, 8, 9]` |
| 3 | Easy | **Transpose Matrix** | Given a matrix $A$, return the transpose of $A$. The transpose of a matrix is the matrix flipped over its main diagonal, switching the row and column indices of the matrix. The function signature should be `def transpose(matrix: list[list[int]]) -> list[list[int]]:`. | **Input:** `matrix = [[1, 2, 3], [4, 5, 6]]`<br>**Expected Output:** `[[1, 4], [2, 5], [3, 6]]` |
| 4 | Medium | **Set Matrix Zeroes** | Given an $m \times n$ integer matrix, if an element is 0, set its entire row and column to 0s. You must do this **in-place**. The function signature should be `def set_zeroes(matrix: list[list[int]]) -> None:`. | **Input:** `matrix = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]`<br>**Expected Output:** `matrix` becomes `[[1, 0, 1], [0, 0, 0], [1, 0, 1]]` |
| 5 | Medium | **Rotate Image (90 Degrees)** | You are given an $n \times n$ 2D matrix representing an image. Rotate the image by 90 degrees (clockwise) **in-place**. The function signature should be `def rotate_image(matrix: list[list[int]]) -> None:`. | **Input:** `matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]`<br>**Expected Output:** `matrix` becomes `[[7, 4, 1], [8, 5, 2], [9, 6, 3]]` |
| 6 | Medium | **Spiral Matrix** | Given an $m \times n$ matrix, return all elements of the matrix in spiral order. The function signature should be `def spiral_order(matrix: list[list[int]]) -> list[int]:`. | **Input:** `matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]`<br>**Expected Output:** `[1, 2, 3, 6, 9, 8, 7, 4, 5]` |
| 7 | Medium | **Number of Islands** | Given an $m \times n$ 2D binary grid which represents a map of '1's (land) and '0's (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. The function signature should be `def num_islands(grid: list[list[str]]) -> int:`. | **Input:** `grid = [["1", "1", "1", "1", "0"], ["1", "1", "0", "1", "0"], ["1", "1", "0", "0", "0"], ["0", "0", "0", "0", "0"]]`<br>**Expected Output:** `1` |
| 8 | Medium | **Valid Sudoku** | Determine if a $9 \times 9$ Sudoku board is valid. Only the filled cells need to be validated according to the following rules: 1. Each row must contain the digits 1-9 without repetition. 2. Each column must contain the digits 1-9 without repetition. 3. Each of the nine $3 \times 3$ sub-boxes must contain the digits 1-9 without repetition. The function signature should be `def is_valid_sudoku(board: list[list[str]]) -> bool:`. | **Input:** A valid $9 \times 9$ partial Sudoku board (string digits and '.')<br>**Expected Output:** `True` |
| 9 | Medium | **Unique Paths** | A robot is located at the top-left corner of an $m \times n$ grid. The robot can only move either down or right at any point in time. It is trying to reach the bottom-right corner of the grid. How many possible unique paths are there? The function signature should be `def unique_paths(m: int, n: int) -> int:`. (Hint: Dynamic Programming or Combinatorics). | **Input:** $m=3$, $n=7$<br>**Expected Output:** `28` |
| 10 | Hard | **Longest Increasing Path in a Matrix** | Given an $m \times n$ integer matrix, find the length of the longest increasing path. From each cell, you can move to four directions: left, right, up, or down. You may not move diagonally or move outside the boundary. Your solution must use **Depth First Search (DFS) with Memoization**. The function signature should be `def longest_increasing_path(matrix: list[list[int]]) -> int:`. | **Input:** `matrix = [[9, 9, 4], [6, 6, 8], [2, 1, 1]]`<br>**Expected Output:** `4` (The path is $1 \to 2 \to 6 \to 9$) |

-----

Please provide your Python code for each of the 10 problems now. Use the ID and Title as comments for each solution function.