You are looking for a highly focused assessment on the most common and essential **Sorting & Searching** interview problems, using the same table format and constraints. I'll prioritize problems like QuickSort, MergeSort, and critical Binary Search variations.

Here is the complete set of 10 problems:

| ID | Difficulty | Title | Problem Description | Example Case |
| :---: | :---: | :--- | :--- | :--- |
| 1 | Easy | **Basic Binary Search** | Given a **sorted** list of integers `nums` and an integer `target`, return the index of `target` if it is found in the list, otherwise return -1. Your solution must run in $O(\log n)$ time. The function signature should be `def binary_search(nums: list[int], target: int) -> int:`. | **Input:** `nums = [-1, 0, 3, 5, 9, 12]`, `target = 5`<br>**Expected Output:** `3` |
| 2 | Easy | **Square Root (Integer)** | Compute and return the integer square root of a non-negative integer $x$. Since the return type is an integer, the decimal digits should be truncated. Your solution must use **Binary Search** and run in $O(\log x)$ time. The function signature should be `def my_sqrt(x: int) -> int:`. | **Input:** $x = 8$<br>**Expected Output:** `2` |
| 3 | Easy | **Find First Occurrence** | Given a sorted array `nums` possibly containing duplicates, and a `target` value, find the index of the **first occurrence** of the target. Return -1 if the target is not found. Your solution must use a modified **Binary Search**. The function signature should be `def find_first_occurrence(nums: list[int], target: int) -> int:`. | **Input:** `nums = [2, 4, 4, 4, 6, 8]`, `target = 4`<br>**Expected Output:** `1` |
| 4 | Medium | **Implement Merge Sort** | Implement the **Merge Sort** algorithm. The function should return a new, sorted list. Your implementation must demonstrate the recursive "Divide and Conquer" approach resulting in $O(n \log n)$ time complexity. The function signature should be `def merge_sort(nums: list[int]) -> list[int]:`. | **Input:** `nums = [5, 2, 4, 6, 1, 3]`<br>**Expected Output:** `[1, 2, 3, 4, 5, 6]` |
| 5 | Medium | **Implement Quick Sort** | Implement the **Quick Sort** algorithm using the **Lomuto or Hoare partition scheme**. The function should sort the input list of integers in-place. Your implementation must clearly show the partitioning logic. The function signature should be `def quick_sort(nums: list[int], low: int, high: int) -> None:`. | **Input:** `nums = [10, 7, 8, 9, 1, 5]`, `low=0`, `high=5`<br>**Expected Output:** `nums` becomes `[1, 5, 7, 8, 9, 10]` |
| 6 | Medium | **Search in Rotated Sorted Array** | Given a sorted array of unique integers `nums` that has been rotated at some unknown pivot, and a target value, return the index of the target if found, otherwise return -1. Your solution must run in $O(\log n)$ time. The function signature should be `def search_rotated(nums: list[int], target: int) -> int:`. | **Input:** `nums = [4, 5, 6, 7, 0, 1, 2]`, `target = 1`<br>**Expected Output:** `5` |
| 7 | Medium | **Find Peak Element** | Find a peak element in a list of integers, which is an element that is strictly greater than its neighbors. If the list contains multiple peaks, return the index to any of the peaks. Your solution should run in $O(\log n)$ time. The function signature should be `def find_peak_element(nums: list[int]) -> int:`. | **Input:** `nums = [1, 2, 3, 1]`<br>**Expected Output:** `2` (index of $3$) |
| 8 | Medium | **Kth Smallest Element in a Sorted Matrix** | Given an $n \times n$ matrix where each of the rows and columns are sorted in ascending order, find the $k$-th smallest element in the matrix. Note that it is the $k$-th smallest element overall, not the $k$-th distinct element. You must use an approach that leverages the sorted nature for efficiency (e.g., Binary Search on the *value* range or a Min-Heap). The function signature should be `def kth_smallest(matrix: list[list[int]], k: int) -> int:`. | **Input:** `matrix = [[1, 5, 9], [10, 11, 13], [12, 13, 15]]`, $k=8$<br>**Expected Output:** `13` |
| 9 | Medium | **Two Sum II - Sorted Input** | Given a **1-indexed sorted** list of integers `numbers` and a `target` value, find two numbers such that they add up to `target`. Return the indices of the two numbers, $index_1$ and $index_2$, as a list. Your solution must use a searching or pointer technique for $O(n)$ time complexity. The function signature should be `def two_sum_sorted(numbers: list[int], target: int) -> list[int]:`. | **Input:** `numbers = [2, 7, 11, 15]`, `target = 9`<br>**Expected Output:** `[1, 2]` |
| 10 | Hard | **Median of Two Sorted Arrays** | Given two sorted arrays `nums1` and `nums2` of size $m$ and $n$ respectively, return the median of the two sorted arrays. The overall run time complexity should be $O(\log(\min(m, n)))$. The function signature should be `def find_median_sorted_arrays(nums1: list[int], nums2: list[int]) -> float:`. | **Input:** `nums1 = [1, 3]`, `nums2 = [2]`<br>**Expected Output:** `2.0` |

-----

Please provide your Python code for each of the 10 problems now. Use the ID and Title as comments for each solution function.