That's a great request. As a Senior Technical Interviewer and Expert Prompt Engineer, I've designed a focused assessment on Arrays. Here is the complete set of 10 problems, structured as requested.

| ID | Difficulty | Title | Problem Description | Example Case |
| :---: | :---: | :--- | :--- | :--- |
| 1 | Easy | **Find the Single Element** | Given a non-empty list of integers where every element appears twice except for one, find that single one. The function signature should be `def find_single_element(nums: list[int]) -> int:`. | **Input:** `nums = [4, 1, 2, 1, 2]`<br>**Expected Output:** `4` |
| 2 | Easy | **Check for Monotonic Array** | Determine if a given list of integers is *monotonic* (either entirely non-decreasing or entirely non-increasing). An empty list or a list with one element is considered monotonic. The function signature should be `def is_monotonic(nums: list[int]) -> bool:`. | **Input:** `nums = [1, 2, 2, 3]`<br>**Expected Output:** `True` |
| 3 | Easy | **Merge Sorted Lists** | Given two **sorted** lists of integers, `nums1` and `nums2`, merge `nums2` into `nums1` such that `nums1` becomes a single sorted list. Assume `nums1` has enough space to hold elements from both lists. The function signature should be `def merge_sorted(nums1: list[int], m: int, nums2: list[int], n: int) -> None:`, where $m$ and $n$ are the number of elements initialized in `nums1` and `nums2`, respectively. The modification should be *in-place*. | **Input:** `nums1 = [1, 2, 3, 0, 0, 0]`, $m=3$, `nums2 = [2, 5, 6]`, $n=3$<br>**Expected Output:** `nums1` becomes `[1, 2, 2, 3, 5, 6]` |
| 4 | Medium | **Container With Most Water** | Given a list of non-negative integers representing $n$ vertical lines where the two endpoints of line $i$ are $(i, \text{height}[i])$ and $(i, 0)$. Find two lines that together with the x-axis form a container, such that the container holds the maximum amount of water. The function signature should be `def max_area(height: list[int]) -> int:`. | **Input:** `height = [1, 8, 6, 2, 5, 4, 8, 3, 7]`<br>**Expected Output:** `49` |
| 5 | Medium | **Three Sum** | Given an integer list `nums`, return all unique triplets $\left[ \text{nums}[i], \text{nums}[j], \text{nums}[k] \right]$ such that $\text{nums}[i] + \text{nums}[j] + \text{nums}[k] = 0$. The solution set must not contain duplicate triplets. The function signature should be `def three_sum(nums: list[int]) -> list[list[int]]:`. | **Input:** `nums = [-1, 0, 1, 2, -1, -4]`<br>**Expected Output:** `[[-1, -1, 2], [-1, 0, 1]]` |
| 6 | Medium | **Rotate Image** | You are given an $n \times n$ 2D matrix representing an image. Rotate the image by 90 degrees (clockwise) **in-place**. The function signature should be `def rotate_image(matrix: list[list[int]]) -> None:`. | **Input:** `matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]`<br>**Expected Output:** `matrix` becomes `[[7, 4, 1], [8, 5, 2], [9, 6, 3]]` |
| 7 | Medium | **Product of Array Except Self** | Given a list of integers `nums`, return an list `answer` such that `answer[i]` is equal to the product of all the elements of `nums` except $\text{nums}[i]$. You must write an algorithm that runs in $O(n)$ time and without using the division operation. The function signature should be `def product_except_self(nums: list[int]) -> list[int]:`. | **Input:** `nums = [1, 2, 3, 4]`<br>**Expected Output:** `[24, 12, 8, 6]` |
| 8 | Medium | **Longest Consecutive Sequence** | Given an unsorted list of integers `nums`, return the length of the longest consecutive elements sequence. Your algorithm must run in $O(n)$ time. The function signature should be `def longest_consecutive(nums: list[int]) -> int:`. | **Input:** `nums = [100, 4, 200, 1, 3, 2]`<br>**Expected Output:** `4` (The sequence is $1, 2, 3, 4$) |
| 9 | Medium | **Jump Game** | You are given an integer list `nums`. You are initially positioned at the list's first index, and each element in the list represents your maximum jump length at that position. Determine if you can reach the last index. The function signature should be `def can_jump(nums: list[int]) -> bool:`. | **Input:** `nums = [2, 3, 1, 1, 4]`<br>**Expected Output:** `True` |
| 10 | Hard | **First Missing Positive** | Given an unsorted list of integers `nums`, find the smallest missing positive integer. You must implement an algorithm that runs in $O(n)$ time and uses constant extra space. The function signature should be `def first_missing_positive(nums: list[int]) -> int:`. | **Input:** `nums = [7, 8, 9, 11, 12]`<br>**Expected Output:** `1` |

-----

Please provide your Python code for each of the 10 problems now. Use the ID and Title as comments for each solution function.