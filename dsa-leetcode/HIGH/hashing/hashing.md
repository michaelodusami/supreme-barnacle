A comprehensive technical interview assessment on **Hashing** should focus on how hash tables (dictionaries/hash maps) are used to achieve $O(1)$ average-case time complexity for lookups, insertions, and deletions, and how this technique solves various problems efficiently.

Here is the complete set of 10 problems focusing on Hashing, following all your constraints.

| ID | Difficulty | Title | Problem Description | Example Case |
| :---: | :---: | :--- | :--- | :--- |
| 1 | Easy | **Two Sum** | Given a list of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`. You may assume that each input would have exactly one solution, and you may not use the same element twice. Your solution should use a hash map for $O(n)$ time complexity. The function signature should be `def two_sum(nums: list[int], target: int) -> list[int]:`. | **Input:** `nums = [2, 7, 11, 15]`, `target = 9`<br>**Expected Output:** `[0, 1]` |
| 2 | Easy | **Count Unique Elements** | Given an unsorted list of integers `nums`, return the total count of distinct (unique) elements in the list. The function signature should be `def count_unique(nums: list[int]) -> int:`. | **Input:** `nums = [1, 2, 2, 3, 1, 4, 5, 4]`<br>**Expected Output:** `5` |
| 3 | Easy | **First Unique Character in a String** | Given a string $s$, find the index of the first character that is unique (appears only once). If no unique character exists, return -1. Your solution should use a frequency map. The function signature should be `def first_unique_char(s: str) -> int:`. | **Input:** `s = "leetcode"`<br>**Expected Output:** `0` |
| 4 | Medium | **Group Anagrams** | Given an array of strings `strs`, group the anagrams together. You can return the answer in any order. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase. Your solution must use a hash map to group strings based on their canonical representation. The function signature should be `def group_anagrams(strs: list[str]) -> list[list[str]]:`. | **Input:** `strs = ["eat", "tea", "tan", "ate", "nat", "bat"]`<br>**Expected Output:** `[["eat", "tea", "ate"], ["tan", "nat"], ["bat"]]` |
| 5 | Medium | **Longest Consecutive Sequence** | Given an unsorted list of integers `nums`, return the length of the longest consecutive elements sequence. Your algorithm must run in $O(n)$ time. The function signature should be `def longest_consecutive(nums: list[int]) -> int:`. | **Input:** `nums = [100, 4, 200, 1, 3, 2]`<br>**Expected Output:** `4` (The sequence is $1, 2, 3, 4$) |
| 6 | Medium | **Subarray Sum Equals K** | Given an array of integers `nums` and an integer $k$, return the total number of contiguous subarrays whose sum equals $k$. Your solution should use a prefix sum map to achieve $O(n)$ time complexity. The function signature should be `def subarray_sum(nums: list[int], k: int) -> int:`. | **Input:** `nums = [1, 1, 1]`, $k=2$<br>**Expected Output:** `2` (Subarrays: `[1, 1]` at index 0 and `[1, 1]` at index 1) |
| 7 | Medium | **Contains Duplicate III (Sliding Window + Hashing)** | Given an integer array `nums`, and two integers $k$ and $t$. Return `True` if there are two distinct indices $i$ and $j$ in the array such that $|\text{nums}[i] - \text{nums}[j]| \le t$ and $|i - j| \le k$. Your solution must use a hash-based technique (e.g., bucket sort/hash buckets) combined with a sliding window for efficiency. The function signature should be `def contains_nearby_almost_duplicate(nums: list[int], k: int, t: int) -> bool:`. | **Input:** `nums = [1, 5, 9, 1, 5, 9]`, $k=2$, $t=3$<br>**Expected Output:** `False` |
| 8 | Medium | **Top K Frequent Elements** | Given an integer list `nums` and an integer $k$, return the $k$ most frequent elements. You may return the answer in any order. Your solution must have a time complexity better than $O(n \log n)$ (e.g., using a frequency map and bucket sort/heap). The function signature should be `def top_k_frequent(nums: list[int], k: int) -> list[int]:`. | **Input:** `nums = [1, 1, 1, 2, 2, 3]`, $k=2$<br>**Expected Output:** `[1, 2]` (Order may vary) |
| 9 | Medium | **Ransom Note** | Given two strings, `ransomNote` and `magazine`, return `True` if `ransomNote` can be constructed from `magazine`; otherwise, return `False`. Each letter in `magazine` can only be used once in `ransomNote`. The function signature should be `def can_construct(ransomNote: str, magazine: str) -> bool:`. | **Input:** `ransomNote = "aa"`, `magazine = "aab"`<br>**Expected Output:** `True` |
| 10 | Hard | **Longest Substring with At Most K Distinct Characters** | Given a string $s$ and an integer $k$, find the length of the longest substring that contains at most $k$ distinct characters. This combines the sliding window technique with a hash map for character counts. The function signature should be `def length_of_longest_substring_k_distinct(s: str, k: int) -> int:`. | **Input:** `s = "eceba"`, $k=2$<br>**Expected Output:** `3` (Substring "ece") |

-----

Please provide your Python code for each of the 10 problems now. Use the ID and Title as comments for each solution function.