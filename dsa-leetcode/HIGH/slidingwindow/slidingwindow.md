Of course. Transitioning from general Array problems to the specialized **Sliding Window** technique is a key step in technical preparation. This pattern is essential for optimizing problems that deal with contiguous subarrays or substrings, typically reducing complexity from $O(n^2)$ to $O(n)$.

Here is the complete assessment, focusing exclusively on Sliding Window problems, following all your constraints.

| ID | Difficulty | Title | Problem Description | Example Case |
| :---: | :---: | :--- | :--- | :--- |
| 1 | Easy | **Maximum Subarray Sum of Size K** | Given an array of positive integers `nums` and a positive integer $k$, find the maximum sum of any contiguous subarray of size $k$. The function signature should be `def max_sum_subarray(nums: list[int], k: int) -> int:`. | **Input:** `nums = [2, 1, 5, 1, 3, 2]`, $k=3$<br>**Expected Output:** `9` |
| 2 | Easy | **Average of All Subarrays of Size K** | Given an array of integers `nums` and a positive integer $k$, find the average of all contiguous subarrays of size $k$. The function signature should be `def find_averages(nums: list[int], k: int) -> list[float]:`. | **Input:** `nums = [1, 12, -5, -6, 50, 3]`, $k=4$<br>**Expected Output:** `[0.5, 12.75, 12.0]` |
| 3 | Easy | **Max Consecutive Ones III** | Given a binary array `nums` and an integer $k$, return the maximum number of consecutive `1`'s in the array if you can flip at most $k$ zeros. The function signature should be `def longest_ones(nums: list[int], k: int) -> int:`. | **Input:** `nums = [1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0]`, $k=2$<br>**Expected Output:** `6` |
| 4 | Medium | **Longest Substring Without Repeating Characters** | Given a string $s$, find the length of the longest substring without repeating characters. This is a classic variable-size sliding window problem. The function signature should be `def length_of_longest_substring(s: str) -> int:`. | **Input:** `s = "abcabcbb"`<br>**Expected Output:** `3` |
| 5 | Medium | **Minimum Size Subarray Sum** | Given an array of positive integers `nums` and a positive integer `target`, return the minimal length of a contiguous subarray whose sum is greater than or equal to `target`. If there is no such subarray, return 0. The function signature should be `def min_subarray_len(target: int, nums: list[int]) -> int:`. | **Input:** `target = 7`, `nums = [2, 3, 1, 2, 4, 3]`<br>**Expected Output:** `2` (Subarray is `[4, 3]`) |
| 6 | Medium | **Fruit Into Baskets** | You are visiting a farm that has a single row of fruit trees. Each tree produces fruit of a certain type, represented by an integer in the list `fruits`. You have two baskets, and each basket can only hold one type of fruit. You can start at any tree and must pick exactly one fruit from every tree (moving right) until you cannot. Return the maximum number of fruits you can pick. This is equivalent to finding the longest subarray with at most two distinct elements. The function signature should be `def total_fruit(fruits: list[int]) -> int:`. | **Input:** `fruits = [1, 2, 1, 3, 4, 3, 5]`<br>**Expected Output:** `3` (The best subarray is `[1, 2, 1]`) |
| 7 | Medium | **Find All Anagrams in a String** | Given two strings $s$ and $p$, return a list of all the starting indices of $p$'s anagrams in $s$. You may return the answer in any order. The function signature should be `def find_anagrams(s: str, p: str) -> list[int]:`. | **Input:** `s = "cbaebabacd"`, `p = "abc"`<br>**Expected Output:** `[0, 6]` |
| 8 | Medium | **Longest Repeating Character Replacement** | Given a string $s$ and an integer $k$, you can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most $k$ times. Find the length of the longest substring containing all repeating letters you can get after performing the above operations. The function signature should be `def character_replacement(s: str, k: int) -> int:`. | **Input:** `s = "AABABBA"`, $k=1$<br>**Expected Output:** `4` (e.g., changing one 'B' in "AABBB" results in "AAAA") |
| 9 | Medium | **Subarrays with Product Less Than K** | Given an array of positive integers `nums` and an integer $k$, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than $k$. The function signature should be `def num_subarray_product_less_than_k(nums: list[int], k: int) -> int:`. | **Input:** `nums = [10, 5, 2, 6]`, $k=100$<br>**Expected Output:** `8` |
| 10 | Hard | **Minimum Window Substring** | Given two strings $s$ and $t$, find the minimum window substring of $s$ which contains every character in $t$ (including duplicates). If there is no such substring, return an empty string. The function signature should be `def min_window(s: str, t: str) -> str:`. | **Input:** `s = "ADOBECODEBANC"`, `t = "ABC"`<br>**Expected Output:** `"BANC"` |

-----

Please provide your Python code for each of the 10 problems now. Use the ID and Title as comments for each solution function.
The included video is a detailed explanation of the Sliding Window technique, which is directly relevant to this entire set of problems.

[Sliding Window in 7 minutes | LeetCode Pattern](https://www.youtube.com/watch?v=y2d0VHdvfdc)
http://googleusercontent.com/youtube_content/1